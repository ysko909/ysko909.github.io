<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8" />
	<meta http-equiv="X-UA-Compatible" content="IE=edge"><title>「Interactivity render mode」と「Interactivity location」とは何か - 頑張らないために頑張る</title><meta name="viewport" content="width=device-width, initial-scale=1">
	<meta property="og:title" content="「Interactivity render mode」と「Interactivity location」とは何か" />
<meta property="og:description" content="概要 .NET 8 からの Blazor Web App テンプレートには、作成ウィザードで Interactivity render mode（どの相互運用モードを有効にするか）と Interactivity location（どこにそのモードを適用するか）という2つの重要な設定があります。
上記のスクショはその作成ウィザードです。日本語化されているためなんだか妙な感じですが、「インタラクティビティ型」が「Interactivity render mode」に、「インタラクティビティ場所」が「Interactivity location」に相当します。単純に直訳しただけじゃん・・・。
この記事では、その概要と仕組み、選択肢ごとの動作や注意点・実装例をまとめます。
Blazor の「レンダーモード」とは Blazor Web App（.NET 8 以降）では、各 Razor コンポーネントが「レンダーモード」を持ちます。これにより「どこで（サーバー／クライアント）」「どの方式で（静的／対話）」描画・イベント処理するかを柔軟に切り替えられます。
   モード 説明 レンダー場所 インタラクティブ     Static Server 静的 SSR（HTML をサーバーで描画して返すのみ） サーバー いいえ   Interactive Server Blazor Server による対話的 SSR サーバー はい   Interactive WebAssembly Blazor WebAssembly によるクライアント側描画（CSR） クライアント はい   Interactive Auto 初回は Server、以降は WASM（バンドル取得後に CSR） サーバー→クライアント はい    なお、対話コンポーネントでは 既定でプレレンダリング（prerendering）有効です。必要ならオフにもできます（一部の例外やWASMのみの構成など、手動調整が必要な場合もあります）。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://ysko909.github.io/posts/basics-of-blazor-web-app-settings-about-interactivity/" /><meta property="article:published_time" content="2025-08-26T18:19:34&#43;09:00"/>
<meta property="article:modified_time" content="2025-08-26T18:19:34&#43;09:00"/><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="「Interactivity render mode」と「Interactivity location」とは何か"/>
<meta name="twitter:description" content="概要 .NET 8 からの Blazor Web App テンプレートには、作成ウィザードで Interactivity render mode（どの相互運用モードを有効にするか）と Interactivity location（どこにそのモードを適用するか）という2つの重要な設定があります。
上記のスクショはその作成ウィザードです。日本語化されているためなんだか妙な感じですが、「インタラクティビティ型」が「Interactivity render mode」に、「インタラクティビティ場所」が「Interactivity location」に相当します。単純に直訳しただけじゃん・・・。
この記事では、その概要と仕組み、選択肢ごとの動作や注意点・実装例をまとめます。
Blazor の「レンダーモード」とは Blazor Web App（.NET 8 以降）では、各 Razor コンポーネントが「レンダーモード」を持ちます。これにより「どこで（サーバー／クライアント）」「どの方式で（静的／対話）」描画・イベント処理するかを柔軟に切り替えられます。
   モード 説明 レンダー場所 インタラクティブ     Static Server 静的 SSR（HTML をサーバーで描画して返すのみ） サーバー いいえ   Interactive Server Blazor Server による対話的 SSR サーバー はい   Interactive WebAssembly Blazor WebAssembly によるクライアント側描画（CSR） クライアント はい   Interactive Auto 初回は Server、以降は WASM（バンドル取得後に CSR） サーバー→クライアント はい    なお、対話コンポーネントでは 既定でプレレンダリング（prerendering）有効です。必要ならオフにもできます（一部の例外やWASMのみの構成など、手動調整が必要な場合もあります）。"/>
<link href="https://fonts.googleapis.com/css?family=Ubuntu:300,400,300italic,400italic|Raleway:200,300"
		rel="stylesheet">

	<link rel="stylesheet" type="text/css" media="screen" href="https://ysko909.github.io/css/normalize.css" />
	<link rel="stylesheet" type="text/css" media="screen" href="https://ysko909.github.io/css/main.css" />
	<link rel="stylesheet" type="text/css" href="https://ysko909.github.io/css/dark.css"
		media="(prefers-color-scheme: dark)"  />
	<script src="https://cdn.jsdelivr.net/npm/feather-icons/dist/feather.min.js"></script><script src="https://ysko909.github.io/js/main.js"></script>
	<script data-ad-client="ca-pub-2615583270378842" async
		src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

	<script data-ad-client="ca-pub-2615583270378842" async
		src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
</head>
<body>
	<div class="container wrapper post">
		<div class="header">
	<h1 class="site-title">頑張らないために頑張る</h1>
	<div class="site-description"><h2>ゆるく頑張ります</h2><nav class="nav social">
			<ul class="flat"><a href="https://twitter.com/unknown_strings" title="Twitter"><i data-feather="twitter"></i></a><a href="https://github.com/ysko909" title="Github"><i data-feather="github"></i></a><a href="/index.xml" title="RSS"><i data-feather="rss"></i></a></ul>
		</nav>
	</div>

	<nav class="nav">
		<ul class="flat">
			
			<li>
				<a href="/">Home</a>
			</li>
			
			<li>
				<a href="/about">About</a>
			</li>
			
			<li>
				<a href="https://forms.gle/mtbEheX7qDrZfKPP8">Contact</a>
			</li>
			
			<li>
				<a href="ppolicy/">Privacy policy</a>
			</li>
			
			<li>
				<a href=""></a>
			</li>
			
		</ul>
	</nav>
</div>


		<div class="post-header">
			<h1 class="title">「Interactivity render mode」と「Interactivity location」とは何か</h1>
			<div class="meta">Posted at &mdash; Aug 26, 2025</div>
		</div>

		<div class="markdown">
			

<h2 id="概要">概要</h2>

<p>.NET 8 からの Blazor Web App テンプレートには、作成ウィザードで <strong>Interactivity render mode</strong>（どの相互運用モードを有効にするか）と <strong>Interactivity location</strong>（どこにそのモードを適用するか）という2つの重要な設定があります。</p>

<p><img src="image.png" alt="alt text" /></p>

<p>上記のスクショはその作成ウィザードです。日本語化されているためなんだか妙な感じですが、「インタラクティビティ型」が「Interactivity render mode」に、「インタラクティビティ場所」が「Interactivity location」に相当します。単純に直訳しただけじゃん・・・。</p>

<p>この記事では、その概要と仕組み、選択肢ごとの動作や注意点・実装例をまとめます。</p>

<h2 id="blazor-の-レンダーモード-とは">Blazor の「レンダーモード」とは</h2>

<p>Blazor Web App（.NET 8 以降）では、<strong>各 Razor コンポーネントが「レンダーモード」</strong>を持ちます。これにより「どこで（サーバー／クライアント）」「どの方式で（静的／対話）」描画・イベント処理するかを柔軟に切り替えられます。</p>

<table>
<thead>
<tr>
<th>モード</th>
<th>説明</th>
<th>レンダー場所</th>
<th>インタラクティブ</th>
</tr>
</thead>

<tbody>
<tr>
<td><strong>Static Server</strong></td>
<td>静的 SSR（HTML をサーバーで描画して返すのみ）</td>
<td>サーバー</td>
<td>いいえ</td>
</tr>

<tr>
<td><strong>Interactive Server</strong></td>
<td>Blazor Server による対話的 SSR</td>
<td>サーバー</td>
<td>はい</td>
</tr>

<tr>
<td><strong>Interactive WebAssembly</strong></td>
<td>Blazor WebAssembly によるクライアント側描画（CSR）</td>
<td>クライアント</td>
<td>はい</td>
</tr>

<tr>
<td><strong>Interactive Auto</strong></td>
<td>初回は Server、以降は WASM（バンドル取得後に CSR）</td>
<td>サーバー→クライアント</td>
<td>はい</td>
</tr>
</tbody>
</table>

<p>なお、対話コンポーネントでは <strong>既定でプレレンダリング（prerendering）有効</strong>です。必要ならオフにもできます（一部の例外やWASMのみの構成など、手動調整が必要な場合もあります）。</p>

<h2 id="2つの設定が意味するもの">2つの設定が意味するもの</h2>

<h3 id="1-interactivity-render-mode-どのモードを-サポート-するか">1) Interactivity render mode：どのモードを「サポート」するか</h3>

<p>ウィザードで <strong>None / Server / WebAssembly / Auto</strong> を選びます。これは「<strong>プロジェクトにどの相互運用モードの“配線”を入れるか</strong>」を決めます。生成されるコードやサービス登録・プロジェクト構成が変わります。</p>

<ul>
<li><strong>Server</strong> を選ぶと、<code>AddInteractiveServerComponents()</code> と <code>AddInteractiveServerRenderMode()</code> が組み込まれ、Blazor Server の相互運用が有効化されます。</li>
<li><strong>WebAssembly</strong> を選ぶと、<code>AddInteractiveWebAssemblyComponents()</code> と <code>AddInteractiveWebAssemblyRenderMode()</code> が入り、<strong>クライアント用の .Client プロジェクト</strong>がテンプレートで自動生成されます。</li>
<li><strong>Auto</strong> を選ぶと Server と WASM の両方が有効になり、両者の拡張が登録されます（<code>AddInteractiveServer*</code> と <code>AddInteractiveWebAssembly*</code> の双方）。</li>
<li><strong>None</strong> は静的 SSR のみ（相互運用なし）。後からページやコンポーネントを対話化したくなった場合は、これらの拡張を自分で追加すれば切替可能です。</li>
</ul>

<blockquote>
<p>CLI では <code>--interactivity</code>（<code>-int</code>）で同等の設定が可能です。</p>
</blockquote>

<h3 id="2-interactivity-location-どこに適用するか">2) Interactivity location：どこに適用するか</h3>

<p><strong>Global</strong> と <strong>Per page/component</strong> の 2 択です。これは「<strong>レンダーモードの“適用範囲”</strong>」を意味します。</p>

<ul>
<li><strong>Global</strong>… アプリ全体を対話化。テンプレートでは <code>Components/App.razor</code> の <code>HeadOutlet</code> と <code>Routes</code> に <strong>@rendermode</strong> がセットされ、配下のページ（ルーティングされるページ）が全て同一のレンダーモードとなります。</li>
<li><strong>Per page/component</strong>… 既定は静的 SSR。<strong>必要なページやコンポーネントにだけ</strong> <code>@rendermode InteractiveServer</code> などを明示して対話化します。CLI では <code>--all-interactive</code> オプションで切り替えます。</li>
</ul>

<blockquote>
<p>なお <strong>App（ルートコンポーネント）自体には <code>@rendermode</code> を直接付与できませんが、通常は <code>Routes</code> や <code>HeadOutlet</code> などApp配下のルート要素に指定します（Visual Studio 2022/.NET 8 テンプレートの既定通り）。</strong></p>
</blockquote>

<h3 id="備考-対話化-とは">備考：「対話化」とは</h3>

<p>ここで言う <strong>「対話化」</strong> とは、レンダリング後もコンポーネントを生かして、ブラウザの DOM イベント（クリック、入力、変更など）と C# の処理が連携する状態を指します。</p>

<ul>
<li><strong>Interactive Server</strong> ならサーバー上で C# が動き、SignalR 経由で UI を更新、<br /></li>
<li><strong>Interactive WebAssembly</strong> や <strong>Auto</strong> ならブラウザで .NET ランタイム（WASM）が動いて UI を更新、<br /></li>
</ul>

<p>という形でイベント処理・状態管理を継続します。</p>

<p>以下、<strong>何をしたら「対話化」になるのか</strong>を、具体的な実装単位でまとめます。</p>

<h4 id="1-対話化-の最小実装-per-page-component">1) 「対話化」の最小実装（Per page/component）</h4>

<blockquote>
<p><strong>宣言的に <code>@rendermode</code> を付けるだけ</strong>で、そのページ／コンポーネントが対話化されます。Program.cs 側には対応するモードのサービス登録が必要です。</p>
</blockquote>

<h5 id="例-カウンターページを対話化-サーバー">例：カウンターページを対話化（サーバー）</h5>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-razor" data-lang="razor">@page &#34;/counter&#34;
@rendermode InteractiveServer   &lt;!-- ← これが“対話化”の指定 --&gt;

&lt;h1&gt;Counter&lt;/h1&gt;
&lt;p&gt;Count: @count&lt;/p&gt;
&lt;button class=&#34;btn btn-primary&#34; @onclick=&#34;Increment&#34;&gt;Add&lt;/button&gt;

@code {
    int count = 0;
    void Increment() =&gt; count++;
}</code></pre></div><div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-csharp" data-lang="csharp"><span style="color:#008000">// Program.cs（サーバー）
</span><span style="color:#008000"></span>builder.Services.AddRazorComponents()
    .AddInteractiveServerComponents();

app.MapRazorComponents&lt;App&gt;()
    .AddInteractiveServerRenderMode();</code></pre></div>
<ul>
<li><code>@rendermode</code> を外すと、このページは <strong>Static SSR</strong>（静的 HTML 返却のみ）になり、<code>@onclick</code> などの C# 側イベントは動作しません（フォームの通常送信やリンク遷移のみ動作）。</li>
</ul>

<h5 id="例-一部コンポーネントのみ対話化-ページの中で">例：一部コンポーネントのみ対話化（ページの中で）</h5>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-razor" data-lang="razor">&lt;!-- ページ自体は静的SSRのまま、ボタン部分だけ対話化 --&gt;
&lt;InteractivePanel @rendermode=&#34;InteractiveServer&#34; /&gt;</code></pre></div>
<blockquote>
<p><code>@rendermode</code> は<strong>ページ定義（上部）</strong>にも<strong>コンポーネント呼び出し（インスタンス）</strong>にも書けます。前者は静的インスタンス、後者は任意のモードを個別に割り当て可能です。</p>
</blockquote>

<h4 id="2-アプリ全体を-対話化-global">2) アプリ全体を「対話化」（Global）</h4>

<blockquote>
<p><strong>Routes と HeadOutlet に <code>@rendermode</code> を付ける</strong>と、ルーティングされるページ全体が対話化されます（<strong>Interactivity location: Global</strong> がこれ）。<code>App</code> そのものには指定できません。</p>
</blockquote>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-razor" data-lang="razor">&lt;!-- Components/App.razor --&gt;
&lt;HeadOutlet @rendermode=&#34;InteractiveServer&#34; /&gt;
&lt;Routes     @rendermode=&#34;InteractiveServer&#34; /&gt;</code></pre></div>
<blockquote>
<p>レイアウト（<code>MainLayout</code>）にはレンダーモードを付けられないため、レイアウト配下を全部対話にしたい場合は <strong>Global</strong> で Routes に付与するのが定石です。</p>
</blockquote>

<h4 id="3-wasm-auto-で-対話化-する場合の実装要件">3) WASM/Auto で「対話化」する場合の実装要件</h4>

<ul>
<li><strong>WASM/Auto を使う場合、.Client プロジェクトがテンプレートで自動生成されます。</strong> WASM で動かしたいコンポーネントは、通常 <code>.Client</code> プロジェクトに置くのが推奨ですが、<code>.Server</code> 側からも参照可能です。<code>@rendermode InteractiveWebAssembly</code> などでマークされたコンポーネントは、自動的にWASMバンドルに含まれます（テンプレート既定通り構成するのが安全です）。</li>
</ul>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-csharp" data-lang="csharp"><span style="color:#008000">// Program.cs（サーバー）
</span><span style="color:#008000"></span>builder.Services.AddRazorComponents()
    .AddInteractiveWebAssemblyComponents();

app.MapRazorComponents&lt;App&gt;()
    .AddInteractiveWebAssemblyRenderMode();</code></pre></div>
<ul>
<li><strong>Interactive Auto</strong> は「初回 Server → 後続 WASM」へ切替わるため、<strong>DB 直叩き</strong>のようなサーバー専用依存を UI から分離し、<strong>API 経由</strong>に抽象化しておく必要があります。</li>
<li>Interactive Autoを選ぶ場合は、「Server側の状態がWASM側に自動で引き継がれるわけではない」ため、<strong>状態やデータ取得は必ずAPIや永続ストア経由で実装してください</strong>。</li>
</ul>

<h4 id="4-プレレンダリング-prerender-の扱い">4) プレレンダリング（prerender）の扱い</h4>

<p>対話コンポーネントは <strong>既定でプレレンダリング有効</strong>です。初期描画だけ SSR し、その後に回線確立（Server）や WASM 起動（Client）で“水和（再接続）”します。必要に応じてオフにできます。</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-razor" data-lang="razor">@rendermode @(new InteractiveServerRenderMode(prerender: false))</code></pre></div>
<h4 id="5-よくある注意点-対話化まわりの-ハマりどころ">5) よくある注意点（対話化まわりの“ハマりどころ”）</h4>

<ul>
<li><strong>非シリアライズなパラメータ</strong>（例：<code>RenderFragment</code>）を、対話コンポーネントにそのまま渡すとエラーに。親子を分けて <strong>シリアライズ可能な引数</strong>に揃える等の工夫が必要です（.NET 8時点でも、非シリアライズなパラメータを子コンポーネントに渡すとランタイムエラーになります）。</li>
<li><strong>レイアウトにレンダーモードは付けられない</strong>ため、レイアウト常駐のトースト・ダイアログ等を“常に対話”にしたいなら <strong>Global</strong> を選ぶか、該当部分のみ個別に対話化します。</li>
<li><strong>WASM コンポーネントの配置</strong>：WASM で動かしたい部分は <strong>Client プロジェクトに置く</strong>（Auto でも同様）。Server 側だけに置くとダウンロード対象に入りません。</li>
</ul>

<h4 id="6-対話化-チェックリスト-実装手順のまとめ">6) 「対話化」チェックリスト（実装手順のまとめ）</h4>

<ol>
<li><strong>Program.cs に該当モードを登録</strong><br />

<ul>
<li>Server: <code>AddInteractiveServerComponents()</code> / <code>AddInteractiveServerRenderMode()</code><br /></li>
<li>WASM: <code>AddInteractiveWebAssemblyComponents()</code> / <code>AddInteractiveWebAssemblyRenderMode()</code><br /></li>
<li>Auto: 上記双方を登録。</li>
</ul></li>
<li><strong>適用範囲を決める</strong><br />

<ul>
<li><strong>Global</strong>：<code>Components/App.razor</code> の <code>Routes</code> / <code>HeadOutlet</code> に <code>@rendermode</code>。<br /></li>
<li><strong>Per</strong>：対象ページの先頭、または対象コンポーネントのインスタンスに <code>@rendermode</code>。</li>
</ul></li>
<li><strong>WASM/Auto の場合は .Client に配置</strong>（WASM 実行させたいコンポーネント、レイアウト、ページ）。</li>
<li><strong>（必要に応じ）prerender の有効/無効を調整</strong>。</li>
<li><strong>（必要に応じ）非シリアライズ引数の見直し</strong>、ラッパー化。</li>
</ol>

<h4 id="一言で言えば">一言で言えば</h4>

<ul>
<li><strong>対話化 = <code>@rendermode</code> で“イベントが動くコンポーネント”にする</strong>こと。<br /></li>
<li><strong>Interactivity location</strong> は、その <code>@rendermode</code> を <strong>「全体（Global）」</strong>に付けるか、<strong>「必要なページ／コンポーネントだけ（Per）」</strong>に付けるかの違いです。</li>
</ul>

<h2 id="具体的に何が生成され-どう動くのか">具体的に何が生成され、どう動くのか</h2>

<h3 id="生成されるコード-抜粋">生成されるコード（抜粋）</h3>

<p><strong>Server を有効</strong>にした場合（例）：</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-csharp" data-lang="csharp"><span style="color:#008000">// Program.cs（サーバー）
</span><span style="color:#008000"></span>builder.Services.AddRazorComponents()
    .AddInteractiveServerComponents();

app.MapRazorComponents&lt;App&gt;()
    .AddInteractiveServerRenderMode();</code></pre></div>
<p><strong>WASM を有効</strong>にした場合（例）：</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-csharp" data-lang="csharp"><span style="color:#008000">// Program.cs（サーバー）
</span><span style="color:#008000"></span>builder.Services.AddRazorComponents()
    .AddInteractiveWebAssemblyComponents();

app.MapRazorComponents&lt;App&gt;()
    .AddInteractiveWebAssemblyRenderMode();
// <span style="">テンプレートでは</span> .Client <span style="">プロジェクトも生成される</span></code></pre></div>
<p><strong>Auto を有効</strong>にした場合（例）：</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-csharp" data-lang="csharp">builder.Services.AddRazorComponents()
    .AddInteractiveServerComponents()
    .AddInteractiveWebAssemblyComponents();

app.MapRazorComponents&lt;App&gt;()
    .AddInteractiveServerRenderMode()
    .AddInteractiveWebAssemblyRenderMode();</code></pre></div>
<p>（上の構成は公式ガイドとテンプレートの既定パターンに準拠）</p>

<h3 id="global-と-per-の違い-app-razor-の例">Global と Per の違い（App.razor の例）</h3>

<ul>
<li><strong>Global</strong> の場合（例：全体を Interactive Server に）：</li>
</ul>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-razor" data-lang="razor">&lt;!-- Components/App.razor --&gt;
&lt;HeadOutlet @rendermode=&#34;InteractiveServer&#34; /&gt;
&lt;Routes     @rendermode=&#34;InteractiveServer&#34; /&gt;</code></pre></div>
<p>これでルーティングされるページはすべて対話化されます。</p>

<ul>
<li><strong>Per page/component</strong> の場合（例：一部のページのみ対話化）：</li>
</ul>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-razor" data-lang="razor">@page &#34;/counter&#34;
@rendermode InteractiveServer

&lt;h1&gt;Counter&lt;/h1&gt;
&lt;button class=&#34;btn btn-primary&#34; @onclick=&#34;Increment&#34;&gt;Add&lt;/button&gt;

@code {
    int count = 0;
    void Increment() =&gt; count++;
}</code></pre></div>
<p>このページだけが対話的になり、他のページは静的 SSR のままです。</p>

<h2 id="interactivity-render-mode-別の効果とトレードオフ">「Interactivity render mode」別の効果とトレードオフ</h2>

<h3 id="static-server-none-を選択">Static Server（None を選択）</h3>

<ul>
<li><strong>長所</strong>：最小構成・高速応答・SEO フレンドリー。SignalR 接続や WASM バンドルが不要。<br /></li>
<li><strong>短所</strong>：JS なしのフォーム送信や強化ナビゲーションは使えるが（フレームワーク側の支援）、コンポーネントの双方向バインディングやイベント駆動UIは不可。</li>
</ul>

<h3 id="interactive-server-server-を選択">Interactive Server（Server を選択）</h3>

<ul>
<li><strong>長所</strong>：<strong>初期表示が速く</strong>、.NET コードはサーバーで実行。接続さえ維持できれば強力な双方向 UI が構築可能。<br /></li>
<li><strong>短所</strong>：<strong>SignalR 接続（WebSocket 等）</strong>が必要でスケール戦略に注意。非シリアライズ可能な引数（複雑な RenderFragment など）を子へ渡すとエラーになります（.NET 8時点でも制約あり）。</li>
</ul>

<h3 id="interactive-webassembly-webassembly-を選択">Interactive WebAssembly（WebAssembly を選択）</h3>

<ul>
<li><strong>長所</strong>：<strong>完全クライアント実行</strong>。オフライン耐性やクライアント性能の活用が可能。<br /></li>
<li><strong>短所</strong>：初回ダウンロードが大きく、<strong>.Client プロジェクト</strong>によるバンドル生成と配置が前提。サーバー資源への直接アクセスは不可（API 越しに設計を統一）。</li>
</ul>

<h3 id="interactive-auto-auto-を選択">Interactive Auto（Auto を選択）</h3>

<ul>
<li><strong>長所</strong>：初回は Server で素早くレンダリングし、バンドル取得後は WASM に<strong>自動スイッチ</strong>。体感速度とクライアント性能の両取りが可能。<br /></li>
<li><strong>短所</strong>：<strong>モード切替時の状態管理</strong>やデータ取得の設計がカギ。DB 直結のままでは WASM へ移行後に失われるため、<strong>抽象化（サービス／API）</strong>が必須。状態の自動引き継ぎ（Rehydration）は現状限定的なので注意。</li>
</ul>

<h2 id="interactivity-location-の影響と選び方">「Interactivity location」の影響と選び方</h2>

<h3 id="global-を選ぶ場合">Global を選ぶ場合</h3>

<ul>
<li><strong>App.razor の Routes／HeadOutlet に @rendermode が付与</strong>され、全ページが対話化されます。<strong>Visual Studio のウィザードで「Global」を選べば自動設定</strong>されます。</li>
<li><strong>WASM／Auto をグローバル適用</strong>する場合は、<strong>レイアウトやページを .Client 側へ配置</strong>する必要があります（テンプレート手順どおり）。これはクライアントバンドルへの含有のためです。</li>
<li><strong>向くケース</strong>：アプリ全域で UI ライブラリのプロバイダー（トースト／ダイアログ等）を常時使いたい、レイアウト層も含めて一貫して対話化したい場合など。</li>
</ul>

<h3 id="per-page-component-を選ぶ場合">Per page/component を選ぶ場合</h3>

<ul>
<li><strong>必要な場所だけ対話化</strong>でき、SSR ページと共存させやすい。パフォーマンスや SEO を重視する画面は SSR のままにできます。</li>
<li>レイアウトに対話コンポーネント（メッセンジャー／ダイアログ等）を直接置くと<strong>非対話ページで問題</strong>になり得ます。対話ページ専用のレイアウトを設けるか、UI設計を工夫しましょう。</li>
<li><strong>向くケース</strong>：一部のページだけ高度な双方向 UI が必要、段階的導入をしたい、サーバー負荷と UX の最適バランスを取りたい、など。</li>
</ul>

<h2 id="実務でよく使うパターンとコード断片">実務でよく使うパターンとコード断片</h2>

<h3 id="1-アプリ全体を-interactive-server-global">1) アプリ全体を Interactive Server（Global）</h3>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-razor" data-lang="razor">&lt;!-- Components/App.razor --&gt;
&lt;HeadOutlet @rendermode=&#34;InteractiveServer&#34; /&gt;
&lt;Routes     @rendermode=&#34;InteractiveServer&#34; /&gt;</code></pre></div><div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-csharp" data-lang="csharp"><span style="color:#008000">// Program.cs
</span><span style="color:#008000"></span>builder.Services.AddRazorComponents().AddInteractiveServerComponents();
app.MapRazorComponents&lt;App&gt;().AddInteractiveServerRenderMode();</code></pre></div>
<p>（ルーター経由のページにモードが伝播。<code>App</code> 自体に指定できない点に注意）</p>

<h3 id="2-一部ページのみ-wasm-per-page-component">2) 一部ページのみ WASM（Per page/component）</h3>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-razor" data-lang="razor">@page &#34;/chart&#34;
@rendermode InteractiveWebAssembly</code></pre></div><div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-csharp" data-lang="csharp"><span style="color:#008000">// Program.cs（サーバー）
</span><span style="color:#008000"></span>builder.Services.AddRazorComponents()
    .AddInteractiveWebAssemblyComponents();

app.MapRazorComponents&lt;App&gt;()
    .AddInteractiveWebAssemblyRenderMode();

// .Client <span style="">プロジェクトを含め、対象コンポーネントは</span> Client <span style="">側でビルド</span></code></pre></div>
<p>（WASM コンポーネントは Client プロジェクトに置く）</p>

<h3 id="3-auto-初回-server-以降-wasm-状態設計の注意">3) Auto（初回 Server → 以降 WASM）＋ 状態設計の注意</h3>

<p>Auto を使うと<strong>最初はサーバー実行</strong>、以降は<strong>WASM 実行</strong>に切り替わるため、<strong>DB アクセス等は抽象化</strong>して <strong>WASM では API 経由</strong>に統一すると破綻しにくいです。Server側の状態がWASM側に自動で引き継がれるわけではありません。</p>

<h2 id="どれを選ぶべきか">どれを選ぶべきか</h2>

<ul>
<li><strong>インフラ簡素化／最速応答重視</strong>：まずは <strong>Static + Per</strong>（必要箇所だけ対話化）。</li>
<li><strong>既存のサーバー資産を活かす双方向 UI</strong>：<strong>Interactive Server</strong>。SignalR 前提のスケール計画は要検討。</li>
<li><strong>クライアント性能をフル活用／オフライン要件</strong>：<strong>Interactive WASM</strong>。API 設計と Client プロジェクトの導線が鍵。</li>
<li><strong>起動体験とその後の操作性を両立</strong>：<strong>Interactive Auto</strong>。状態管理やデータ取得の抽象化を最初から設計に織り込む。</li>
</ul>

<p>具体的なユースケースを考えてみます。</p>

<h3 id="1-社内システム-イントラネット-業務アプリ">1. 社内システム（イントラネット・業務アプリ）</h3>

<ul>
<li><strong>推奨モード</strong>：<strong>Interactive Server</strong>

<ul>
<li>理由：イントラネット環境では SignalR 接続が安定しやすく、サーバー側で .NET コードを直接実行できるため、開発がシンプル。</li>
<li><strong>Auto や WASM は不要</strong>（オフライン要件がなければ）。</li>
</ul></li>
<li><strong>Interactivity location</strong>：<strong>Global</strong>

<ul>
<li>理由：業務アプリは全ページで双方向 UI が必要なことが多い。</li>
</ul></li>
<li><strong>注意点</strong>：スケールアウト時は SignalR のバックプレーン（Redis など）を検討。</li>
</ul>

<h3 id="2-パブリックな-web-サイト-seo-重視-情報提供中心">2. パブリックな Web サイト（SEO 重視・情報提供中心）</h3>

<ul>
<li><strong>推奨モード</strong>：<strong>Static Server（None）＋ Per page/component</strong>

<ul>
<li>理由：SEO と初期表示速度を最優先。基本は SSR、必要な箇所（フォームや検索 UI）だけ対話化。</li>
</ul></li>
<li><strong>Interactivity location</strong>：<strong>Per page/component</strong>

<ul>
<li>理由：全ページを対話化するとオーバーヘッドが大きい。</li>
</ul></li>
<li><strong>補足</strong>：フォームや検索結果ページだけ <code>@rendermode InteractiveServer</code> を付与。</li>
</ul>

<h3 id="3-web-アプリ-saas-外部ユーザー向け">3. Web アプリ（SaaS・外部ユーザー向け）</h3>

<ul>
<li><strong>推奨モード</strong>：<strong>Interactive Auto</strong>

<ul>
<li>理由：初回は SSR で高速表示、その後 WASM に切替えて UX 向上。SaaS では体感速度と操作性が重要。</li>
</ul></li>
<li><strong>Interactivity location</strong>：<strong>Global</strong>

<ul>
<li>理由：アプリ全体で一貫した UX を提供したい。</li>
</ul></li>
<li><strong>注意点</strong>：Auto は状態管理が難しいので、API 経由のデータ取得を設計段階で導入。</li>
</ul>

<h3 id="4-pwa-オフライン対応-モバイル重視">4. PWA（オフライン対応・モバイル重視）</h3>

<ul>
<li><strong>推奨モード</strong>：<strong>Interactive WebAssembly</strong>

<ul>
<li>理由：完全クライアント実行が必須。オフライン対応やキャッシュ戦略を組み込みやすい。</li>
</ul></li>
<li><strong>Interactivity location</strong>：<strong>Global</strong>

<ul>
<li>理由：PWA は全体でオフライン動作を想定するため。</li>
</ul></li>
<li><strong>補足</strong>：Service Worker と組み合わせ、API 同期戦略を設計。</li>
</ul>

<h3 id="まとめ表"><strong>まとめ表</strong></h3>

<table>
<thead>
<tr>
<th>ユースケース</th>
<th>Render Mode</th>
<th>Location</th>
</tr>
</thead>

<tbody>
<tr>
<td>社内システム</td>
<td>Interactive Server</td>
<td>Global</td>
</tr>

<tr>
<td>パブリックサイト</td>
<td>Static + Interactive Server (一部)</td>
<td>Per page/component</td>
</tr>

<tr>
<td>Web アプリ</td>
<td>Interactive Auto</td>
<td>Global</td>
</tr>

<tr>
<td>PWA</td>
<td>Interactive WASM</td>
<td>Global</td>
</tr>
</tbody>
</table>

<h2 id="よくあるつまずき">よくあるつまずき</h2>

<ul>
<li><strong>「WASM を選んだのに動かない」</strong><br />
WASM 対話を使うには <strong>.Client プロジェクト</strong>が必要で、WASM で動かすコンポーネントは <strong>Client 側でビルド対象に含める</strong>必要があります。テンプレートの構成に従いましょう。</li>
<li><strong>「レイアウトにレンダーモードを付けたい」</strong><br />
レイアウト自体に@rendermodeは付与できませんが、レイアウト内部で必要な部分に個別指定や、Routesのグローバル指定でカバーします。</li>
<li><strong>「Interactive Server でエラー（非シリアライズな引数）」</strong><br />
たとえば RenderFragment などをそのまま渡すと問題になることがあります。<strong>親子分割でシリアライズ可能な引数に揃える</strong>等の回避が必要です（UI ライブラリ利用時は注意）。</li>
<li><strong>「プレレンダリングを切りたい」</strong><br />
既定でオン。必要に応じて <code>@rendermode @(new InteractiveServerRenderMode(prerender:false))</code> のように切替可能です。</li>
</ul>

<h2 id="visual-studio-cli-での設定対応">Visual Studio／CLI での設定対応</h2>

<ul>
<li>Visual Studio 2022の新規Blazor Web Appウィザードで「Interactivity」「Location」を選択でき、CLIでは <code>--interactivity</code> <code>--all-interactive</code> が対応します（.NET 8以降、<code>blazor</code> テンプレートはWeb App専用）。</li>
</ul>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">  dotnet new blazor <span style="color:#a31515">\
</span><span style="color:#a31515"></span>    --interactivity Server|WebAssembly|Auto|None <span style="color:#a31515">\
</span><span style="color:#a31515"></span>    --all-interactive true|false</code></pre></div>
<p>（<code>--interactivity</code> がモード、<code>--all-interactive</code> が Global/Per の切り替え）</p>

<h2 id="まとめ">まとめ</h2>

<p>なかなか選択肢が多くて<del>ﾒﾝﾄﾞｸｻｲ</del>大変ですが、要点は以下の通りです。</p>

<ul>
<li><strong>Interactivity render mode</strong> は「<strong>どの相互運用モードをサポートするか</strong>」で、<code>Program.cs</code> のサービス／エンドポイント登録や .Client プロジェクトの有無に関わります。</li>
<li><strong>Interactivity location</strong> は「<strong>そのモードをどこに適用するか</strong>」。<strong>Global</strong> は <code>Routes</code>／<code>HeadOutlet</code> に <code>@rendermode</code> を付与、<strong>Per page/component</strong> は必要なページやコンポーネントだけに <code>@rendermode</code> を付けます。</li>
<li>WASM／Auto を <strong>Global</strong> で使う場合は、<strong>レイアウト／ページを .Client に配置</strong>する点が肝。Auto では<strong>切替時の状態・データの設計</strong>が成功の分かれ目です。</li>
</ul>

<h2 id="参考">参考</h2>

<ol>
<li><a href="https://learn.microsoft.com/ja-jp/aspnet/core/blazor/components/render-modes?view=aspnetcore-9.0">ASP.NET Core Blazor のレンダー モード</a></li>
<li><a href="https://zenn.dev/microsoft/articles/blazor-dotnet8-comp-state">.NET 8 の Blazor で静的 SSR と InteractveServer/WASM 間の状態渡し</a></li>
<li><a href="https://stackoverflow.com/questions/77613680/what-does-interactivity-location-mean-when-creating-a-blazor-app-from-a-templa">What does &lsquo;interactivity location&rsquo; mean when creating a Blazor App from a template?</a></li>
</ol>

		</div><div id="disqus_thread"></div>
<script type="text/javascript">
	(function () {
		
		
		if (window.location.hostname == "localhost")
			return;

		var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
		var disqus_shortname = 'come-as-you-are';
		dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
		(document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
	})();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by
		Disqus.</a></noscript>
<a href="http://disqus.com/" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
</div>
	<div class="footer wrapper">
	<nav class="nav">
		<div> © Copyright ysko |  <a href="https://github.com/vividvilla/ezhil">Ezhil theme</a> | Built with <a href="https://gohugo.io">Hugo</a></div>
	</nav>
</div>


<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-140331728-1', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>
<script>feather.replace()</script>
</body>
</html>
