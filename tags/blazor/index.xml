<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Blazor on 頑張らないために頑張る</title>
    <link>https://ysko909.github.io/tags/blazor/</link>
    <description>Recent content in Blazor on 頑張らないために頑張る</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja</language>
    <copyright>© Copyright ysko</copyright>
    <lastBuildDate>Wed, 10 Dec 2025 10:20:05 +0900</lastBuildDate>
    
	<atom:link href="https://ysko909.github.io/tags/blazor/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Blazor Serverでデータをブラウザコンソールに出力する方法</title>
      <link>https://ysko909.github.io/posts/how-to-output-to-the-browser-console-using-blazor/</link>
      <pubDate>Wed, 10 Dec 2025 10:20:05 +0900</pubDate>
      
      <guid>https://ysko909.github.io/posts/how-to-output-to-the-browser-console-using-blazor/</guid>
      <description>概要 Blazor Serverアプリケーションを開発していると、デバッグのためにブラウザのコンソールにデータを出力したくなることよくがあります。まぁ「デバッガー使えばいいじゃん」はたしかにそうなのですが、単純に「ここの処理通過してるか見ておきたいなー」程度の確認のとき、パッと「********hoge処理通過********」とか適当な文字列をコンソールに出したりします。
しかし、ことBlazorでの開発の場合、コンソールに出力するSystem.Diagnostics.Debug.WriteLine()やConsole.WriteLine()を使っても、ブラウザのコンソールには表示されません。今回はこの点について書きたいと思います。
なぜ表示されないのか 結論から言えば、Blazor Serverの仕組みに起因しています。
Blazor Serverでは、C#のコードはサーバー側で実行されます。
 System.Diagnostics.Debug.WriteLine() → （サーバー側である）Visual Studioのデバッグコンソールに出力 Console.WriteLine() → サーバーのコンソール(ターミナル)に出力  上記のようにそれぞれ「サーバー側」で実行され出力されます。しかし、ブラウザはクライアント側で動作しているため、サーバー側のコンソール出力は見えないのです。考えれば当たり前体操なのですが、つい忘れがち。
解決方法: JSInteropを使う 出力されているところはわかったのですが、「確認したいんだよぉ、ブラウザのコンソールでよぉ！」を実現するにはまあまあ面倒です。というのも、ブラウザのコンソールに出力するにはJavaScript Interop (JSInterop) を使って、JavaScriptのconsole.log()を呼び出す必要があります。
方法1: IJSRuntimeを直接使用する 最もシンプルな方法は、IJSRuntimeを使ってJavaScriptのconsole.logを直接呼び出すことです。
@page &amp;#34;/console-example&amp;#34; @inject IJSRuntime JS &amp;lt;h3&amp;gt;ブラウザコンソール出力のデモ&amp;lt;/h3&amp;gt; &amp;lt;button @onclick=&amp;#34;LogToConsole&amp;#34;&amp;gt;ブラウザコンソールに出力&amp;lt;/button&amp;gt; @code { private async Task LogToConsole() { await JS.InvokeVoidAsync(&amp;#34;console.log&amp;#34;, &amp;#34;Hello from Blazor Server!&amp;#34;); } } この方法には以下のようなメリットがあります。
 InvokeVoidAsync() を使用(戻り値が不要な場合) 第一引数に&amp;quot;console.log&amp;quot;を指定 第二引数以降に出力したいデータを指定  方法2: 複数の値やオブジェクトを出力する @code { private async Task LogMultipleValues() { var user = new { Name = &amp;#34;田中太郎&amp;#34;, Age = 30 }; await JS.</description>
    </item>
    
    <item>
      <title>OnInitializedAsync()が2回実行されるのはBlazorの「仕様」</title>
      <link>https://ysko909.github.io/posts/why-is-the-oninitializedasync-executed-twice/</link>
      <pubDate>Wed, 19 Nov 2025 14:13:03 +0900</pubDate>
      
      <guid>https://ysko909.github.io/posts/why-is-the-oninitializedasync-executed-twice/</guid>
      <description>概要 Blazorを用いてコンポーネントを書き始めると、「あれ？」と思う現象があります。それが、OnInitializedAsyncメソッドが2回実行されるという現象です。これのせいで、「データを2回も取得してる」「ログが二重に記録されてる」という事象が発生します。
これはバグではなく、Blazorの「プリレンダリング (Prerendering)」という機能による意図的な動作です。この記事では、なぜこの現象が起きるのか、そしてそれにどうスマートに対処すればよいのかを、Microsoftのドキュメントを基に解説します。
TL;DR  OnInitializedAsync は2回実行される挙動は、Blazorのプリレンダリング（Prerendering）という機能によって引き起こされます。つまり仕様です。 ランダムな値の生成やデータベースへの問い合わせなどを単純に書くと、1回目と2回目で異なる結果になったり処理が2重に走ったりして、「画面が一瞬ちらつく」「表示される値が変わる」という現象が起きます。 この現象を抑制するには PersistentComponentState （永続コンポーネント状態）サービスを利用します。  そもそも「プリレンダリング」とは？ Blazor (特にBlazor ServerやBlazor Web App) には、ユーザー体験を向上させるための「プリレンダリング」という仕組みがデフォルトで備わっています。
これは、ユーザーがページにアクセスした際、まずサーバー側でコンポーネントを実行し、その結果を静的なHTMLとして先にブラウザに送信する技術です。
プリレンダリングのメリット  初期表示が高速: JavaScriptの読み込みやSignalR接続が完了する前に、ユーザーはページのコンテンツを見ることができます。 SEOに有利: クローラーが静的なHTMLを読み取れるため、検索エンジン最適化（SEO）に役立ちます。  OnInitializedAsyncが2回実行されるメカニズム このプリレンダリングの仕組みこそが、OnInitializedAsyncが2回呼ばれる原因です。
 1回目（静的プリレンダリング）: ユーザーがページにアクセスした瞬間、サーバー側でページのHTMLを高速に生成し、ブラウザに返します。これにより、ユーザーは待機時間なく画面を見ることができます（SEO対策にもなります）。この時、最初のOnInitializedAsyncが走ります。 2回目（対話的接続の確立）: HTMLが表示された直後、ブラウザはサーバーとのWebSocket接続（SignalR）を確立（またはWASMをロード）し、改めて「動的なアプリケーション」としてコンポーネントを再構築します。ここで2回目のOnInitializedAsyncが走ります。  1回目の実行: サーバーでのプリレンダリング時  目的：できるだけ早く静的 HTML を返す（SEO/初期表示の体感向上） 特徴：OnAfterRender{Async} は呼ばれない（JS Interop 不可） いつ？：ユーザーがページをリクエストした直後、サーバーサイドで。 何が起こる？：Blazorはコンポーネントをインスタンス化し、OnInitializedAsync を実行します。ここでAPIからデータを取得するコードがあれば、それが実行されます。 結果：取得したデータを含む静的なHTMLが生成され、ブラウザに送信されます。 状態：この時点では、ボタンをクリックしても何も起こりません。まだインタラクティブ（操作可能）ではありません。  2回目の実行: クライアントでのインタラクティブ化（ハイドレーション）時  目的：イベント ハンドラ有効化／実動状態へ昇格（Server は SignalR、WASM はランタイムでの起動） 特徴：OnInitialized{Async} が再度実行、この後に OnAfterRender{Async}(firstRender=true) が初めて呼ばれる いつ？：ブラウザが静的HTMLを受け取った後、必要なJavaScriptファイル（Blazor ServerならSignalR接続、Blazor WebAssemblyならWASMランタイム）の読み込みと実行が完了した時、クライアントサイドで。 何が起こる？：Blazorは再度コンポーネントをインスタンス化し、OnInitializedAsync をもう一度実行します。 結果：プリレンダリングされたDOM（HTML）と、クライアント側で実行されたコンポーネントの状態が関連付けられ（これをハイドレーションと呼びます）、ページが完全にインタラクティブになります。 状態：これ以降、ボタンのクリックなどに反応するようになります。   要するに:</description>
    </item>
    
    <item>
      <title>Blazorアプリ作成時の各設定項目</title>
      <link>https://ysko909.github.io/posts/blazor-web-app-configration/</link>
      <pubDate>Mon, 14 Jul 2025 12:23:15 +0900</pubDate>
      
      <guid>https://ysko909.github.io/posts/blazor-web-app-configration/</guid>
      <description>概要 自分はメインのエディタをVisual Studio Codeを使ってたせいで、Blazorアプリを新規作成するときは大抵dotnet new blazorwasm -o MyBlazorAppのようにコマンドラインで実行しちゃってます。が、BlazorアプリをVisual Studio 2022（以下、VS2022）を使って開発する際はこの方法じゃなくて、ウィザードを利用する方法が主流です。その際は、開発するアプリの仕様についてウィザードに設定する必要があります。
この記事では、これらの項目をどのように設定すればいいか、作成したいアプリケーションとともに考えます。かなり自分目線の備忘録的意味合いが強いので、その点ご了承ください。
入力項目 フレームワーク (Framework) アプリが動作する基盤となる.NETのバージョンを選択します。
 .NET 8.0 (長期的なサポート - LTS): Long-Term Supportの略で、長期間にわたってセキュリティパッチやバグ修正が提供される安定バージョンです。商用プロジェクトや長期間運用するシステムでは、こちらを選択するのが一般的です。 その他のバージョン (例: .NET 9.0): Standard-Term Support (STS) やプレビュー版が含まれます。最新の機能を試したい場合や、短いライフサイクルのプロジェクトに適していますが、サポート期間はLTSより短くなります。  なお、現状ではサポート期間は以下の通り設定されています。
   バージョン 開始日 終了日     .NET 9 2024年11月12日 2026年5月12日   .NET 8 (LTS) 2023年11月14日 2026年11月10日    基本的に.NETのLTSは偶数バージョンに設定されており、奇数バージョンはSTSです。そのため、直近の偶数バージョンを選択することで自動的にLTSを選択できます。これについては、直近偶数バージョンの指定で決め打ちして問題ないと思います。
認証の種類 (Authentication type) ユーザー認証の方式を選択します。
 なし (None): 認証機能を組み込みません。 個別のアカウント (Individual Accounts): ASP.</description>
    </item>
    
  </channel>
</rss>