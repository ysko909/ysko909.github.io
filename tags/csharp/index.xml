<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Csharp on 頑張らないために頑張る</title>
    <link>https://ysko909.github.io/tags/csharp/</link>
    <description>Recent content in Csharp on 頑張らないために頑張る</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja</language>
    <copyright>© Copyright ysko</copyright>
    <lastBuildDate>Wed, 19 Nov 2025 14:13:03 +0900</lastBuildDate>
    
	<atom:link href="https://ysko909.github.io/tags/csharp/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>OnInitializedAsync()が2回実行されるのはBlazorの「仕様」</title>
      <link>https://ysko909.github.io/posts/why-is-the-oninitializedasync-executed-twice/</link>
      <pubDate>Wed, 19 Nov 2025 14:13:03 +0900</pubDate>
      
      <guid>https://ysko909.github.io/posts/why-is-the-oninitializedasync-executed-twice/</guid>
      <description>概要 Blazorを用いてコンポーネントを書き始めると、「あれ？」と思う現象があります。それが、OnInitializedAsyncメソッドが2回実行されるという現象です。これのせいで、「データを2回も取得してる」「ログが二重に記録されてる」という事象が発生します。
これはバグではなく、Blazorの「プリレンダリング (Prerendering)」という機能による意図的な動作です。この記事では、なぜこの現象が起きるのか、そしてそれにどうスマートに対処すればよいのかを、Microsoftのドキュメントを基に解説します。
TL;DR  OnInitializedAsync は2回実行される挙動は、Blazorのプリレンダリング（Prerendering）という機能によって引き起こされます。つまり仕様です。 ランダムな値の生成やデータベースへの問い合わせなどを単純に書くと、1回目と2回目で異なる結果になったり処理が2重に走ったりして、「画面が一瞬ちらつく」「表示される値が変わる」という現象が起きます。 この現象を抑制するには PersistentComponentState （永続コンポーネント状態）サービスを利用します。  そもそも「プリレンダリング」とは？ Blazor (特にBlazor ServerやBlazor Web App) には、ユーザー体験を向上させるための「プリレンダリング」という仕組みがデフォルトで備わっています。
これは、ユーザーがページにアクセスした際、まずサーバー側でコンポーネントを実行し、その結果を静的なHTMLとして先にブラウザに送信する技術です。
プリレンダリングのメリット  初期表示が高速: JavaScriptの読み込みやSignalR接続が完了する前に、ユーザーはページのコンテンツを見ることができます。 SEOに有利: クローラーが静的なHTMLを読み取れるため、検索エンジン最適化（SEO）に役立ちます。  OnInitializedAsyncが2回実行されるメカニズム このプリレンダリングの仕組みこそが、OnInitializedAsyncが2回呼ばれる原因です。
 1回目（静的プリレンダリング）: ユーザーがページにアクセスした瞬間、サーバー側でページのHTMLを高速に生成し、ブラウザに返します。これにより、ユーザーは待機時間なく画面を見ることができます（SEO対策にもなります）。この時、最初のOnInitializedAsyncが走ります。 2回目（対話的接続の確立）: HTMLが表示された直後、ブラウザはサーバーとのWebSocket接続（SignalR）を確立（またはWASMをロード）し、改めて「動的なアプリケーション」としてコンポーネントを再構築します。ここで2回目のOnInitializedAsyncが走ります。  1回目の実行: サーバーでのプリレンダリング時  目的：できるだけ早く静的 HTML を返す（SEO/初期表示の体感向上） 特徴：OnAfterRender{Async} は呼ばれない（JS Interop 不可） いつ？：ユーザーがページをリクエストした直後、サーバーサイドで。 何が起こる？：Blazorはコンポーネントをインスタンス化し、OnInitializedAsync を実行します。ここでAPIからデータを取得するコードがあれば、それが実行されます。 結果：取得したデータを含む静的なHTMLが生成され、ブラウザに送信されます。 状態：この時点では、ボタンをクリックしても何も起こりません。まだインタラクティブ（操作可能）ではありません。  2回目の実行: クライアントでのインタラクティブ化（ハイドレーション）時  目的：イベント ハンドラ有効化／実動状態へ昇格（Server は SignalR、WASM はランタイムでの起動） 特徴：OnInitialized{Async} が再度実行、この後に OnAfterRender{Async}(firstRender=true) が初めて呼ばれる いつ？：ブラウザが静的HTMLを受け取った後、必要なJavaScriptファイル（Blazor ServerならSignalR接続、Blazor WebAssemblyならWASMランタイム）の読み込みと実行が完了した時、クライアントサイドで。 何が起こる？：Blazorは再度コンポーネントをインスタンス化し、OnInitializedAsync をもう一度実行します。 結果：プリレンダリングされたDOM（HTML）と、クライアント側で実行されたコンポーネントの状態が関連付けられ（これをハイドレーションと呼びます）、ページが完全にインタラクティブになります。 状態：これ以降、ボタンのクリックなどに反応するようになります。   要するに:</description>
    </item>
    
    <item>
      <title>「Interactivity render mode」と「Interactivity location」とは何か</title>
      <link>https://ysko909.github.io/posts/basics-of-blazor-web-app-settings-about-interactivity/</link>
      <pubDate>Tue, 26 Aug 2025 18:19:34 +0900</pubDate>
      
      <guid>https://ysko909.github.io/posts/basics-of-blazor-web-app-settings-about-interactivity/</guid>
      <description>概要 .NET 8 からの Blazor Web App テンプレートには、作成ウィザードで Interactivity render mode（どの相互運用モードを有効にするか）と Interactivity location（どこにそのモードを適用するか）という2つの重要な設定があります。
上記のスクショはその作成ウィザードです。日本語化されているためなんだか妙な感じですが、「インタラクティビティ型」が「Interactivity render mode」に、「インタラクティビティ場所」が「Interactivity location」に相当します。単純に直訳しただけじゃん・・・。
この記事では、その概要と仕組み、選択肢ごとの動作や注意点・実装例をまとめます。
Blazor の「レンダーモード」とは Blazor Web App（.NET 8 以降）では、各 Razor コンポーネントが「レンダーモード」を持ちます。これにより「どこで（サーバー／クライアント）」「どの方式で（静的／対話）」描画・イベント処理するかを柔軟に切り替えられます。
   モード 説明 レンダー場所 インタラクティブ     Static Server 静的 SSR（HTML をサーバーで描画して返すのみ） サーバー いいえ   Interactive Server Blazor Server による対話的 SSR サーバー はい   Interactive WebAssembly Blazor WebAssembly によるクライアント側描画（CSR） クライアント はい   Interactive Auto 初回は Server、以降は WASM（バンドル取得後に CSR） サーバー→クライアント はい    なお、対話コンポーネントでは 既定でプレレンダリング（prerendering）有効です。必要ならオフにもできます（一部の例外やWASMのみの構成など、手動調整が必要な場合もあります）。</description>
    </item>
    
    <item>
      <title>Entity Framework マイグレーションの基本</title>
      <link>https://ysko909.github.io/posts/fundamentals-of-migration-on-entity-framework/</link>
      <pubDate>Fri, 22 Aug 2025 14:41:09 +0900</pubDate>
      
      <guid>https://ysko909.github.io/posts/fundamentals-of-migration-on-entity-framework/</guid>
      <description>概要 マイグレーションとは何か マイグレーション（Migration）とは、データベースの構造変更を安全かつ自動的に行うためのEntity Frameworkの機能です。
C#のモデルクラス（設計図）の変更を検出し、それに合わせてデータベースの実際のテーブル構造を更新するプロセスを指します。「移行」という意味の通り、データベースを現在の状態から新しい状態へと段階的に移行させる仕組みです。この機能を利用することで、データベースに対する操作やSQLの作成と実行と言った、従来だと当たり前のように行っていた作業を簡素化することが可能です。
最近はBlazor絡みのシステムに携わることが多いのですが、データベースをいじるときはEntity Framework（以下、EF）を使っています。今回はこのEFを利用する際に必要になるマイグレーションに関して、基本的な知識や実行方法についてまとめてみました。
EF＆マイグレーションのメリット  SQL不要：C#だけで完結 エラー減少：自動生成でヒューマンエラー防止 開発スピードUP：数分でDB更新  事前準備：プロジェクトにEF Coreを導入する マイグレーションを始める前に、まずはBlazorプロジェクトにEntity Framework Core (EF Core) を導入し、データベースと通信できるように設定しましょう。ここが全ての土台となります。
ステップ1：必要なパッケージのインストール Visual Studioの「パッケージマネージャーコンソール」で以下のコマンドを実行し、EF Coreに必要なツールをインストールします。
# データベースプロバイダー (ここではSQL Server) Install-Package Microsoft.EntityFrameworkCore.SqlServer # EF Coreのコマンドラインツール Install-Package Microsoft.EntityFrameworkCore.Tools ステップ2：接続文字列の設定 データベースの場所や認証情報を定義します。プロジェクトルートにあるappsettings.jsonファイルに、以下のようにConnectionStringsを追加します。
{ &amp;#34;ConnectionStrings&amp;#34;: { &amp;#34;DefaultConnection&amp;#34;: &amp;#34;Server=(localdb)\\mssqllocaldb;Database=MyBlazorAppDb;Trusted_Connection=True;&amp;#34; }, &amp;#34;Logging&amp;#34;: { // ... }, &amp;#34;AllowedHosts&amp;#34;: &amp;#34;*&amp;#34; }  Server=(localdb)\\mssqllocaldb: Visual Studioと一緒にインストールされる開発用のSQL Serverです。 Database=MyBlazorAppDb: これから作成するデータベース名です。  ステップ3：DbContextの登録 アプリケーション全体でデータベース接続を使い回せるように、Program.csにDbContextを「サービス」として登録します。これは「依存性の注入（DI）」と呼ばれる仕組みで、「必要な時に自動でDbContextを準備してください」と.NETにお願いするおまじないのようなものだと思ってください。
Program.csファイルを開き、builder.Build()の前に以下のコードを追加してください。
// using Microsoft.EntityFrameworkCore; をファイルの先頭に追加  var connectionString = builder.</description>
    </item>
    
  </channel>
</rss>